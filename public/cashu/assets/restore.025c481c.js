import{a as W}from"./index.916cb52e.js";import{u as R}from"./index.42f06193.js";import{f as k,e as b,F as C,a as B,W as D,X as F,Y as I,u as U,E as X,l as v}from"./ui.b6121134.js";const r=200,M=2,Y=W("restore",{state:()=>({showRestoreDialog:R("cashu.restore.showRestoreDialog",!1),restoringState:!1,restoringMint:"",mnemonicToRestore:R("cashu.restore.mnemonicToRestore",""),restoreProgress:0,restoreCounter:0,restoreStatus:""}),getters:{},actions:{restoreMint:async function(n){this.restoringState=!0,this.restoringMint=n,this.restoreProgress=0,this.restoreCounter=0,this.restoreStatus="";try{await this._restoreMint(n)}catch(u){k(`Error restoring mint: ${u}`)}finally{this.restoringState=!1,this.restoringMint="",this.restoreProgress=0}},_restoreMint:async function(n){if(this.mnemonicToRestore.length===0){k("Please enter a mnemonic");return}this.restoreProgress=0;const u=b(),T=C();await B().activateMintUrl(n);const E=this.mnemonicToRestore;this.restoreStatus="Preparing restore process...";const p=new D(n),d=(await p.getKeySets()).keysets;let P=!1,h=d.length*M,a=0;for(const t of d){console.log(`Restoring keyset ${t.id} with unit ${t.unit}`);const A=u.mnemonicToSeedSync(E),y=new F(p,{bip39seed:A,unit:t.unit});let c=0,m=0,f=[];for(;m<M;){console.log(`Restoring proofs ${c} to ${c+r}`);const e=(await y.restore(c,r,{keysetId:t.id})).proofs;e.length===0?(console.log(`No proofs found for keyset ${t.id}`),m++):(console.log(`> Restored ${e.length} proofs with sum ${e.reduce((s,S)=>s+S.amount,0)}`),f=f.concat(e),m=0,this.restoreCounter+=e.length,h+=1),this.restoreStatus=`Restored ${this.restoreCounter} proofs for keyset ${t.id}`,c+=r,a++,this.restoreProgress=a/h}let g=[];for(let e=0;e<f.length;e+=r){this.restoreStatus=`Checking proofs ${e} to ${e+r} for keyset ${t.id}`;const s=f.slice(e,e+r),S=await y.checkProofsStates(s),N=s.filter((o,i)=>S[i].state===I.SPENT).map(o=>o.secret),l=s.filter(o=>!N.includes(o.secret));l.length>0&&console.log(`Found ${l.length} unspent proofs with sum ${l.reduce((o,i)=>o+i.amount,0)}`);const $=l.filter(o=>!T.proofs.some(i=>i.secret===o.secret));await C().addProofs($),g=g.concat($),a++,this.restoreProgress=a/h}const w=g.reduce((e,s)=>e+s.amount,0),_=U().formatCurrency(w,t.unit);w>0&&(X(`Restored ${_}`),P=!0)}P||v("No proofs found to restore")}}});export{Y as u};
